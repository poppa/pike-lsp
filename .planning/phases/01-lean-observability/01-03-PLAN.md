---
phase: 01-lean-observability
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified:
  - pike-scripts/LSP.pmod/module.pmod
  - packages/pike-bridge/src/bridge.ts
  - packages/pike-bridge/src/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Pike make_error() helper returns flat error dicts"
    - "Error dicts have error, kind, msg, line fields"
    - "Bridge captures Pike stderr and logs via Logger"
    - "Bridge wraps Pike errors in PikeError class"
    - "Error wrapping preserves cause chain"
  artifacts:
    - path: "pike-scripts/LSP.pmod/module.pmod"
      provides: "make_error() helper function"
      contains: "mapping make_error"
    - path: "packages/pike-bridge/src/bridge.ts"
      provides: "Logger integration, stderr capture, PikeError wrapping"
      contains: "import.*Logger"
  key_links:
    - from: "packages/pike-bridge/src/bridge.ts"
      to: "pike-scripts/LSP.pmod/module.pmod"
      via: "JSON-RPC error response parsing"
      pattern: "response.error"
    - from: "packages/pike-bridge/src/bridge.ts"
      to: "@pike-lsp/pike-lsp-server/core/logging"
      via: "ESM import"
      pattern: "import.*Logger"
---

<objective>
Create Pike error helper and integrate Logger into PikeBridge for stderr capture and error wrapping.

Purpose: Establish the cross-boundary error contract. Pike returns flat error dicts via JSON-RPC; Bridge captures stderr and wraps errors in PikeError class with proper cause chaining.

Output: make_error() helper in Pike, Logger integration in Bridge, PikeError wrapping on failures
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-lean-observability/01-CONTEXT.md
@.planning/phases/01-lean-observability/01-RESEARCH.md

# Prior work (after 01-01, 01-02 complete)
@.planning/phases/01-lean-observability/01-01-SUMMARY.md
@.planning/phases/01-lean-observability/01-02-SUMMARY.md

# Existing code
@pike-scripts/LSP.pmod/module.pmod
@packages/pike-bridge/src/bridge.ts
@packages/pike-bridge/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Add make_error() helper to Pike module.pmod</name>
  <files>pike-scripts/LSP.pmod/module.pmod</files>
  <action>
Read pike-scripts/LSP.pmod/module.pmod and add make_error() function at the end:

```pike
//! Create a flat error dictionary for JSON-RPC error responses
//! @param kind The error kind (e.g., "SYNTAX", "COMPILE", "RUNTIME")
//! @param msg The error message
//! @param line Optional line number where error occurred
//! @returns A mapping with error, kind, msg, line fields
mapping make_error(string kind, string msg, int|void line) {
    return ([
        "error": 1,
        "kind": kind,
        "msg": msg,
        "line": line
    ]);
}
```

This is a simple helper - no complex error objects, just flat mappings for JSON serialization.

DO NOT: Try to implement stack traces or complex error types in Pike. The philosophy (from CONTEXT.md) is that Pike lacks stack context, so we keep it simple and let TypeScript add the chain.
  </action>
  <verify>
  - Pike compiles: `pike -e 'compile_file("pike-scripts/LSP.pmod/module.pmod");'`
  - Function exists: `pike -e 'write(describe_type(LSP.module.make_error));'` outputs "function"
  </verify>
  <done>
make_error() function exists in LSP.module, returns flat error dicts
  </done>
</task>

<task type="auto">
  <name>Import Logger into PikeBridge</name>
  <files>packages/pike-bridge/src/bridge.ts</files>
  <action>
Read packages/pike-bridge/src/bridge.ts and add Logger import:

1. Add import at top:
   ```typescript
   import { Logger, LogLevel } from '@pike-lsp/pike-lsp-server/core';
   ```

2. Create a logger instance in the constructor (after super() call):
   ```typescript
   private readonly logger = new Logger('PikeBridge');
   ```

NOTE: @pike-lsp/pike-lsp-server/core is available because pike-bridge package.json has it as a workspace dependency. The core module is in packages/pike-lsp-server/src/core/.

IMPORTANT: Do NOT add pike-lsp-server as a dependency of pike-bridge. The import works because:
1. Both are in the same monorepo with workspace: protocol
2. pike-bridge can use server's utilities through TypeScript module resolution
3. The core module has no circular dependencies on bridge
  </action>
  <verify>
  - TypeScript compiles: `cd packages/pike-bridge && pnpm build`
  - No import errors for @pike-lsp/pike-lsp-server/core
  </verify>
  <done>
Logger is imported and instance created in PikeBridge
  </done>
</task>

<task type="auto">
  <name>Replace stderr handler with Logger integration</name>
  <files>packages/pike-bridge/src/bridge.ts</files>
  <action>
Find the stderr handler in PikeBridge (around line 165-184) and modify it:

1. Replace this.debugLog() calls with logger.debug()
2. Keep the suppressedPatterns filtering (false positive warnings)
3. Log stderr events via Logger instead of debugLog

Example pattern:
```typescript
this.process.stderr?.on('data', (data: Buffer) => {
    const message = data.toString().trim();
    if (message) {
        const suppressedPatterns = [/^Illegal comment/, /^Missing ['"]>?['"]\)/];
        const isSuppressed = suppressedPatterns.some(p => p.test(message));

        if (!isSuppressed) {
            this.logger.debug('Pike stderr', { raw: message });
            this.emit('stderr', message);
        } else {
            this.logger.trace('Pike stderr (suppressed)', { raw: message });
        }
    }
});
```

DO NOT: Remove the this.emit('stderr', message) line - other code may depend on the stderr event.
  </action>
  <verify>
  - TypeScript compiles: `cd packages/pike-bridge && pnpm build`
  - Bridge still emits stderr events
  - Logger is used for stderr capture
  </verify>
  <done>
Pike stderr is logged via Logger with proper level filtering
  </done>
</task>

<task type="auto">
  <name>Wrap Pike errors in PikeError class</name>
  <files>packages/pike-bridge/src/bridge.ts</files>
  <action>
Find the handleResponse method in PikeBridge (around line 334-353) and modify error handling:

1. Import PikeError at top with Logger:
   ```typescript
   import { Logger, LogLevel, PikeError } from '@pike-lsp/pike-lsp-server/core';
   ```

2. In handleResponse, when response.error exists, wrap in PikeError:
   ```typescript
   if (response.error) {
       const error = new PikeError(
           response.error.message || 'Pike request failed',
           new Error(response.error.message)
       );
       pending.reject(error);
   }
   ```

3. In sendRequest timeout, wrap in PikeError:
   ```typescript
   reject(new PikeError(`Request ${id} timed out after ${this.options.timeout}ms`));
   ```

4. In process close handler, wrap in PikeError:
   ```typescript
   const error = new PikeError(`Pike process exited with code ${code}`);
   ```

DO NOT: Wrap in BridgeError - these are Pike-side errors, not bridge IPC errors.
  </action>
  <verify>
  - TypeScript compiles: `cd packages/pike-bridge && pnpm build`
  - Unit tests still pass: `cd packages/pike-bridge && pnpm test`
  - Error layer is 'pike' on wrapped errors
  </verify>
  <done>
Pike subprocess errors are wrapped in PikeError with proper layer
  </done>
</task>

<task type="auto">
  <name>Export PikeError from pike-bridge</name>
  <files>packages/pike-bridge/src/index.ts</files>
  <action>
Read packages/pike-bridge/src/index.ts and add PikeError to re-exports:

If the file exports from './bridge.js', also re-export PikeError from the core module:
```typescript
export { PikeError } from '@pike-lsp/pike-lsp-server/core';
```

This allows consumers of pike-bridge to catch PikeError without importing from the server package.

DO NOT: Export LSPError or BridgeError from here - those are server-side concerns. Only PikeError needs to be exported because bridge consumers need to catch Pike subprocess errors.
  </action>
  <verify>
  - TypeScript compiles: `cd packages/pike-bridge && pnpm build`
  - PikeError is importable from '@pike-lsp/pike-bridge'
  </verify>
  <done>
PikeError is exported from pike-bridge for consumer use
  </done>
</task>

</tasks>

<verification>
1. Pike module.pmod compiles: `pike -e 'compile_file("pike-scripts/LSP.pmod/module.pmod");'`
2. Bridge TypeScript compiles: `cd packages/pike-bridge && pnpm build`
3. Bridge tests pass: `cd packages/pike-bridge && pnpm test`
4. make_error() returns flat dicts with correct fields
5. Pike stderr is logged via Logger
6. Pike errors are wrapped in PikeError class
7. Error.chain shows proper path through layers
</verification>

<success_criteria>
- make_error() in Pike returns { error: 1, kind, msg, line }
- Bridge uses Logger for stderr capture (debug/trace levels)
- Pike subprocess errors wrapped in PikeError
- PikeError.layer === 'pike'
- Error chain shows path from server -> bridge -> pike
</success_criteria>

<output>
After completion, create `.planning/phases/01-lean-observability/01-03-SUMMARY.md`
</output>
