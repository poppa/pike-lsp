---
phase: 03-intelligence-module
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pike-scripts/LSP.pmod/Intelligence.pike
autonomous: true

must_haves:
  truths:
    - "Intelligence.pike class can be instantiated via master()->resolv('LSP.Intelligence')->Intelligence"
    - "handle_introspect compiles Pike code and extracts symbols, functions, variables, classes, inherits"
    - "handle_introspect returns JSON-RPC response with result mapping on success"
    - "handle_introspect returns JSON-RPC error response on compilation errors"
    - "handle_resolve resolves module paths to file system locations"
    - "handle_resolve handles local modules (starting with .) correctly"
    - "handle_resolve uses LSP.Cache for program caching"
    - "handle_resolve uses LSP.Compat.trim_whites() for string operations"
    - "handle_resolve uses LSP.debug() for debug logging"
    - "Errors in handlers return LSP.LSPError responses, not exceptions"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Intelligence.pike"
      provides: "Introspection and resolution handler class"
      min_lines: 300
      contains: "class Intelligence", "handle_introspect", "handle_resolve", "introspect_program", "get_module_path"
  key_links:
    - from: "pike-scripts/LSP.pmod/Intelligence.pike"
      to: "pike-scripts/LSP.pmod/Cache.pmod"
      via: "LSP.Cache.put('program_cache', ...)"
      pattern: "LSP\\.Cache\\.put\\('program_cache'"
    - from: "pike-scripts/LSP.pmod/Intelligence.pike"
      to: "pike-scripts/LSP.pmod/Compat.pmod"
      via: "LSP.Compat.trim_whites(...)"
      pattern: "LSP\\.Compat\\.trim_whites"
    - from: "pike-scripts/LSP.pmod/Intelligence.pike"
      to: "pike-scripts/LSP.pmod/module.pmod"
      via: "LSP.debug(...)"
      pattern: "LSP\\.debug\\("
---

<objective>
Create Intelligence.pike with handle_introspect and handle_resolve handlers.

Purpose: Extract two core intelligence handlers from analyzer.pike into a stateless class following Parser.pike pattern.
Output: Intelligence.pike class with introspection and module resolution capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-CONTEXT.md
@.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-RESEARCH.md
@pike-scripts/analyzer.pike
@pike-scripts/LSP.pmod/module.pmod
@pike-scripts/LSP.pmod/Cache.pmod
@pike-scripts/LSP.pmod/Compat.pmod
@pike-scripts/LSP.pmod/Parser.pike
</context>

<tasks>

<task type="auto">
  <name>Create Intelligence.pike class skeleton with handle_introspect</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
Create new file pike-scripts/LSP.pmod/Intelligence.pike with:

1. File header with module documentation following Parser.pike pattern:
   - "//! Intelligence.pike - Stateless intelligence class for Pike LSP"
   - Stateless design note
   - Use instructions

2. class Intelligence with:
   - void create() - No-op constructor (stateless pattern)
   - handle_introspect(mapping params) - Copied from analyzer.pike lines 1156-1210

3. Key modifications for extraction:
   - Replace program_cache[filename] = compiled_prog with LSP.Cache.put("program_cache", filename, compiled_prog)
   - Replace cache_access_time tracking (handled by Cache.pmod internally)
   - Remove evict_lru_programs() call (handled by Cache.pmod)
   - Replace direct error returns with LSP.LSPError wrapped in catch:
     ```pike
     mixed err = catch {
         // handler logic
     };
     if (err) {
         return LSP.LSPError(-32000, describe_error(err))->to_response();
     }
     ```

4. Protected helper: introspect_program(program prog)
   - Copy from analyzer.pike lines 1650-1790
   - Replace String.trim_whites() with LSP.Compat.trim_whites()
   - This helper is used by handle_introspect and will be used by future handlers

DO NOT copy any handler functions beyond handle_introspect at this point.
  </action>
  <verify>
pike -e "write('Intelligence loads: %d\n', programp(master()->resolv('LSP.Intelligence')->Intelligence));"
  </verify>
  <done>
Intelligence.pike exists, loads successfully, has class Intelligence with handle_introspect method
  </done>
</task>

<task type="auto">
  <name>Add handle_resolve and get_module_path helpers</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
Add to Intelligence.pike:

1. handle_resolve(mapping params) method
   - Copy from analyzer.pike lines 226-333
   - Replace debug() calls with LSP.debug()
   - No caching in handle_resolve (returns file paths, not compiled programs)
   - Wrap in catch returning LSP.LSPError on exception

2. get_module_path(mixed resolved) protected helper
   - Copy from analyzer.pike lines 174-224
   - No modifications needed (pure logic, no dependencies)

3. Extract autodoc comments from source if present in analyzer.pike for these methods
   - Convert //! comments to Pike documentation format

Update file header to document both handlers.
  </action>
  <verify>
pike -e "object I = (program)master()->resolv('LSP.Intelligence')->Intelligence(); write('Methods: %s\n', indices(I));"
  </verify>
  <done>
Intelligence.pike has handle_resolve and get_module_path, both methods accessible via reflection
  </done>
</task>

<task type="auto">
  <name>Add JSON-RPC error wrapping to all handler methods</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
For each handler method (handle_introspect, handle_resolve):

1. Wrap core logic in catch block:
   ```pike
   mapping handle_introspect(mapping params) {
       mixed err = catch {
           // existing handler logic
       };
       if (err) {
           return LSP.LSPError(-32000, describe_error(err))->to_response();
       }
   }
   ```

2. Ensure all success paths return mapping with "result" key
3. Ensure all error paths return LSP.LSPError->to_response() result

This matches Parser.pike pattern where handlers throw errors and wrapper catches them.
  </action>
  <verify>
grep -E "catch|LSP\.LSPError" pike-scripts/LSP.pmod/Intelligence.pike | wc -l
  </verify>
  <done>
Each handler method has catch block with LSP.LSPError response
  </done>
</task>

</tasks>

<verification>
1. Class loads: `pike -e "write('%d\\n', programp(master()->resolv('LSP.Intelligence')->Intelligence));"` returns 1
2. Has expected methods: `pike -e "object I = (program)master()->resolv('LSP.Intelligence')->Intelligence(); write('%O\\n', indices(I));"` contains handle_introspect, handle_resolve
3. Uses LSP.Cache: `grep "LSP.Cache" pike-scripts/LSP.pmod/Intelligence.pike` has matches
4. Uses LSP.Compat: `grep "LSP.Compat.trim_whites" pike-scripts/LSP.pmod/Intelligence.pike` has matches
5. Uses LSP.debug: `grep "LSP.debug" pike-scripts/LSP.pmod/Intelligence.pike` has matches
</verification>

<success_criteria>
1. Intelligence.pike compiles without errors
2. Class follows Parser.pike stateless pattern
3. handle_introspect compiles code and extracts symbols
4. handle_resolve resolves module paths
5. All handlers use LSP infrastructure (Cache, Compat, debug, LSPError)
6. Handler errors return JSON-RPC error responses
</success_criteria>

<output>
After completion, create `.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-01-SUMMARY.md`
</output>
