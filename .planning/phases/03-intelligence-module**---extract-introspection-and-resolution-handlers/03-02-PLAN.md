---
phase: 03-intelligence-module
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - pike-scripts/LSP.pmod/Intelligence.pike
autonomous: true

must_haves:
  truths:
    - "handle_resolve_stdlib resolves stdlib modules using master()->resolv()"
    - "handle_resolve_stdlib uses LSP.Cache for stdlib data caching"
    - "Cache check happens before resolution (returns cached data if available)"
    - "Parsed symbols from source file are merged with introspected symbols"
    - "parse_stdlib_documentation extracts //! comments from stdlib source"
    - "Documentation is merged into introspection results via merge_documentation"
    - "Line number suffix is stripped from Program.defined() paths"
    - "Stdlib cache uses flat module name keys per CONTEXT.md decision"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Intelligence.pike"
      provides: "Stdlib resolution and documentation parsing"
      contains: "handle_resolve_stdlib", "parse_stdlib_documentation", "merge_documentation", "extract_symbol_name"
  key_links:
    - from: "pike-scripts/LSP.pmod/Intelligence.pike"
      to: "pike-scripts/LSP.pmod/Cache.pmod"
      via: "LSP.Cache.get('stdlib_cache', module_path)"
      pattern: "LSP\\.Cache\\.get\\('stdlib_cache'"
    - from: "pike-scripts/LSP.pmod/Intelligence.pike"
      to: "pike-scripts/LSP.pmod/Parser.pike"
      via: "Parser()->parse_request(...) for symbol extraction"
      pattern: "parse_request"
    - from: "pike-scripts/LSP.pmod/Intelligence.pike"
      to: "pike-scripts/LSP.pmod/Compat.pmod"
      via: "LSP.Compat.trim_whites() in parse_stdlib_documentation"
      pattern: "LSP\\.Compat\\.trim_whites"
---

<objective>
Add handle_resolve_stdlib with stdlib caching and documentation parsing.

Purpose: Extract stdlib resolution handler that resolves Pike stdlib modules, caches their symbol data, and parses AutoDoc documentation.
Output: Intelligence.pike with stdlib query capabilities using two-cache architecture.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-CONTEXT.md
@.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-RESEARCH.md
@.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-01-SUMMARY.md
@pike-scripts/analyzer.pike
@pike-scripts/LSP.pmod/Parser.pike
@pike-scripts/LSP.pmod/Cache.pmod
@pike-scripts/LSP.pmod/Compat.pmod
</context>

<tasks>

<task type="auto">
  <name>Add handle_resolve_stdlib method with stdlib caching</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
Add handle_resolve_stdlib(mapping params) method to Intelligence.pike:

1. Copy base implementation from analyzer.pike lines 1213-1327

2. Replace stdlib_cache direct access with LSP.Cache:
   - Replace `if (stdlib_cache[module_path])` with `mapping cached = LSP.Cache.get("stdlib_cache", module_path); if (cached)`
   - Replace `stdlib_cache[module_path] = result` with `LSP.Cache.put("stdlib_cache", module_path, result)`
   - Remove manual LRU eviction (`evict_lru_stdlib()` - handled by Cache.pmod)

3. Replace handle_parse call with Parser class:
   - Replace `mapping parse_response = handle_parse(parse_params);` with:
     ```pike
     program ParserClass = master()->resolv("LSP.Parser")->Parser;
     Parser parser = ParserClass();
     mapping parse_response = parser->parse_request(parse_params);
     ```

4. Keep line number suffix stripping logic (Pitfall 2 from RESEARCH.md):
   - Check for colon in path
   - Validate suffix is numeric
   - Strip suffix before file operations

5. Wrap in catch returning LSP.LSPError on exception

This implements the flat-by-module stdlib cache from CONTEXT.md decision.
  </action>
  <verify>
grep -E "handle_resolve_stdlib|LSP\.Cache.*stdlib_cache" pike-scripts/LSP.pmod/Intelligence.pike
  </verify>
  <done>
handle_resolve_stdlib method exists, uses LSP.Cache for stdlib data, calls Parser.pike for symbol extraction
  </done>
</task>

<task type="auto">
  <name>Add parse_stdlib_documentation and merge_documentation helpers</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
Add protected helpers to Intelligence.pike:

1. parse_stdlib_documentation(string source_path)
   - Copy from analyzer.pike lines 1331-1400
   - Key functionality:
     - Strip line number suffix from source_path (reuse pattern)
     - Read source file using Stdio.read_file()
     - Extract autodoc comments via extract_autodoc_comments helper
     - Parse function/method signatures using extract_symbol_name
     - Return mapping of symbol name -> documentation

2. merge_documentation(mapping introspection, mapping docs)
   - Copy from analyzer.pike lines 1459-1493
   - Merges docs into introspection->symbols, ->functions, ->variables arrays
   - Uses symbol name as key for lookup

3. extract_symbol_name(string line)
   - Copy from analyzer.pike lines 1403-1456
   - Replace String.trim_whites() with LSP.Compat.trim_whites()
   - Extracts function/method name from definition line
   - Handles PIKEFUN pattern for C modules

4. extract_autodoc_comments(string code) helper (if not already present)
   - This is used by parse_stdlib_documentation
   - Check if it exists in analyzer.pike (lines likely 440-471 based on Parser.pike pattern)
   - If found, copy to Intelligence.pike

All helpers should be protected (not public API).
  </action>
  <verify>
grep -E "parse_stdlib_documentation|merge_documentation|extract_symbol_name" pike-scripts/LSP.pmod/Intelligence.pike
  </verify>
  <done>
All three helper methods exist, are protected, use LSP.Compat.trim_whites()
  </done>
</task>

<task type="auto">
  <name>Add parse_autodoc helper for AutoDoc markup processing</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
Add parse_autodoc(string doc) protected helper to Intelligence.pike:

1. Copy from analyzer.pike lines 414-770 (approximately)
   - This is a LARGE function - copy completely

2. Copy dependent helpers:
   - save_text_buffer() from analyzer.pike lines 774+
   - process_inline_markup() from analyzer.pike lines 975+
   - replace_markup() from analyzer.pike lines 1018+
   - format_group_as_text() from analyzer.pike (search for it)

3. String trimming replacement:
   - Replace all String.trim_whites() with LSP.Compat.trim_whites()

4. Token type constants (Pitfall 3 from RESEARCH.md):
   - Keep the comment explaining token types (1=METAKEYWORD, 3=DELIMITERKEYWORD, etc.)
   - Do NOT try to use named constants - Pike uses numeric types

5. Wrap parse_autodoc in its own catch for graceful degradation
   - If AutoDoc parsing fails, return basic text mapping

Note: This function processes Tools.AutoDoc.DocParser tokens into structured documentation.
  </action>
  <verify>
grep -E "parse_autodoc|process_inline_markup|save_text_buffer|replace_markup|format_group_as_text" pike-scripts/LSP.pmod/Intelligence.pike
  </verify>
  <done>
parse_autodoc and all dependent helpers exist, use LSP.Compat.trim_whites(), handle token types correctly
  </done>
</task>

</tasks>

<verification>
1. handle_resolve_stdlib exists: `grep "handle_resolve_stdlib" pike-scripts/LSP.pmod/Intelligence.pike`
2. Uses LSP.Cache for stdlib: `grep "stdlib_cache" pike-scripts/LSP.pmod/Intelligence.pike | grep LSP.Cache`
3. Calls Parser for symbol extraction: `grep "parse_request" pike-scripts/LSP.pmod/Intelligence.pike`
4. Documentation helpers exist: `grep -E "parse_stdlib_documentation|merge_documentation|extract_symbol_name|parse_autodoc" pike-scripts/LSP.pmod/Intelligence.pike`
5. Uses LSP.Compat: `grep "LSP.Compat.trim_whites" pike-scripts/LSP.pmod/Intelligence.pike`
</verification>

<success_criteria>
1. handle_resolve_stdlib resolves stdlib modules via master()->resolv()
2. Stdlib data cached in LSP.Cache with flat module name keys
3. Source file symbols extracted via Parser.pike and merged with introspection
4. Documentation parsed from AutoDoc comments and merged into results
5. Line number suffix stripped from Program.defined() paths
6. Handler errors return JSON-RPC error responses
</success_criteria>

<output>
After completion, create `.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-02-SUMMARY.md`
</output>
