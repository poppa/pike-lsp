---
phase: 05-pike-reorganization
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
  - pike-scripts/LSP.pmod/Analysis.pmod/Diagnostics.pike
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Analysis.pmod directory exists with module.pmod and Diagnostics.pike"
    - "module.pmod contains shared helpers for token navigation and scope tracking"
    - "Diagnostics class contains handle_analyze_uninitialized handler"
    - "Classes use create(object ctx) constructor pattern"
    - "master()->resolv('LSP.Analysis.Diagnostics') returns the class"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      provides: "Shared helpers for token navigation, scope tracking, variable management"
      min_lines: 200
    - path: "pike-scripts/LSP.pmod/Analysis.pmod/Diagnostics.pike"
      provides: "Diagnostics class with uninitialized variable analysis"
      min_lines: 500
  key_links:
    - from: "pike-scripts/LSP.pmod/Analysis.pmod/Diagnostics.pike"
      to: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      via: "Direct function calls for token navigation helpers"
      pattern: "find_next_token|find_matching_brace|find_matching_paren"
---

<objective>
Create the Analysis.pmod directory structure with shared helpers and Diagnostics class.

Purpose: Establish the .pmod module pattern for splitting Analysis.pike, starting with shared helpers in module.pmod (token navigation, scope tracking) and the Diagnostics class for uninitialized variable detection.
Output: Analysis.pmod/ directory with module.pmod (shared helpers) and Diagnostics.pike (diagnostics class)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Phase context
@.planning/phases/05-pike-reorganization/05-CONTEXT.md
@.planning/phases/05-pike-reorganization/05-RESEARCH.md

# Source files to split
@pike-scripts/LSP.pmod/Analysis.pike
@pike-scripts/LSP.pmod/module.pmod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Analysis.pmod directory with module.pmod</name>
  <files>pike-scripts/LSP.pmod/Analysis.pmod/module.pmod</files>
  <action>
    Create directory pike-scripts/LSP.pmod/Analysis.pmod/

    Create module.pmod with shared helper functions extracted from Analysis.pike:

    Constants:
    - constant STATE_UNINITIALIZED = 0;
    - constant STATE_MAYBE_INIT = 1;
    - constant STATE_INITIALIZED = 2;
    - constant STATE_UNKNOWN = 3;
    - constant NEEDS_INIT_TYPES = (< "string", "array", "mapping", "multiset", "object", "function", "program", "mixed" >);

    Type checking helpers:
    - int is_type_keyword(string text) - Check if text is a Pike type keyword
    - int is_identifier(string text) - Check if text is a valid identifier
    - int is_assignment_operator(string text) - Check if text is an assignment operator

    Token navigation helpers:
    - int find_next_token(array tokens, int start_idx, int end_idx, string target)
    - int find_next_meaningful_token(array tokens, int start_idx, int end_idx)
    - int find_prev_meaningful_token(array tokens, int start_idx, int min_idx)
    - int find_matching_brace(array tokens, int start_idx, int end_idx)
    - int find_matching_paren(array tokens, int start_idx, int end_idx)

    Position helpers:
    - int get_char_pos_in_line(array(string) lines, int line_no, string token_text)

    Variable management helpers:
    - void remove_out_of_scope_vars(mapping variables, int scope_depth)
    - mapping save_variable_states(mapping variables)
    - void restore_variable_states(mapping variables, mapping saved)

    Declaration parsing:
    - mapping try_parse_declaration(array tokens, int start_idx, int end_idx)

    Definition detection:
    - int is_function_definition(array tokens, int start_idx, int end_idx)
    - int is_lambda_definition(array tokens, int start_idx, int end_idx)

    Parameter extraction:
    - mapping(string:mapping) extract_function_params(array tokens, int start_idx, int body_start)

    Pattern:
    - Use //! for function documentation
    - Functions are callable directly from classes in the .pmod
    - Use LSP.Compat.trim_whites() for string operations

    DO NOT include (these go in specific class files):
    - analyze_function_body (goes in Diagnostics.pike)
    - analyze_scope (goes in Diagnostics.pike)
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Analysis.is_type_keyword"); if (functionp(m)) { werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>module.pmod exists with 15+ shared helper functions and constants</done>
</task>

<task type="auto">
  <name>Task 2: Create Diagnostics.pike with Diagnostics class</name>
  <files>pike-scripts/LSP.pmod/Analysis.pmod/Diagnostics.pike</files>
  <action>
    Create Diagnostics.pike with class Diagnostics that contains:

    1. Private object context field
    2. void create(object ctx) constructor

    3. Mapping handler:
       - handle_analyze_uninitialized(mapping params) - Main handler entry point

    4. Protected helpers:
       - array(mapping) analyze_uninitialized_impl(string code, string filename)
       - array(mapping) analyze_scope(array tokens, array lines, string filename, int start_idx, int end_idx)
       - array(mapping) analyze_function_body(array tokens, array lines, string filename, int start_idx, int end_idx, mapping initial_vars)

    Handler pattern:
    - Wrap handler body in catch { ... }
    - On error: return (["result": (["diagnostics": ({}))]) (graceful degradation, not crash)
    - Use Parser.Pike.split() and Parser.Pike.tokenize() for tokenization
    - Use LSP.Compat.trim_whites() for string operations
    - Return diagnostics array with: message, severity, position (file, line, character)

    analyze_function_body is the core analysis:
    - Tracks variable declarations with STATE_* constants
    - Detects assignments using is_assignment_operator
    - Detects variable reads (not assignments)
    - Generates diagnostics for variables used before initialization
    - Handles scope depth with { } tracking
    - Handles if/else branch tracking
    - Handles foreach loop variables
    - Handles nested lambda and function definitions

    Use helper functions from module.pmod:
    - find_next_token, find_matching_brace, find_matching_paren
    - find_next_meaningful_token, find_prev_meaningful_token
    - is_type_keyword, is_identifier, is_assignment_operator
    - try_parse_declaration, is_function_definition, is_lambda_definition
    - extract_function_params
    - get_char_pos_in_line
    - remove_out_of_scope_vars, save_variable_states, restore_variable_states
    - STATE_* constants (passed as module.STATE_UNINITIALIZED etc.)

    Include constants at top:
    - Use STATE_* constants from module.pmod (reference as constants or pass through)

    DO NOT include (these go to other files):
    - handle_find_occurrences (goes to Variables.pike)
    - handle_get_completion_context (goes to Completions.pike)
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Analysis.Diagnostics"); if (programp(m)) { object i = m(0); werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>Diagnostics class with handle_analyze_uninitialized method</done>
</task>

<task type="auto">
  <name>Task 3: Verify module loading and create summary</name>
  <files></files>
  <action>
    Run module loading verification:
    1. Test that LSP.Analysis module loads
    2. Test that LSP.Analysis.Diagnostics class exists
    3. Test that module.pmod functions are accessible

    Verification command:
    pike -e '
      master()->add_module_path("pike-scripts");
      mixed mod = master()->resolv("LSP.Analysis");
      if (!mod) { werror("FAIL: LSP.Analysis not loaded\n"); exit(1); }
      werror("OK: LSP.Analysis loaded\n");

      mixed cls = mod->Diagnostics;
      if (!programp(cls)) { werror("FAIL: Diagnostics class not found\n"); exit(1); }
      werror("OK: Diagnostics class found\n");

      object inst = cls(0);
      werror("OK: Diagnostics instantiated\n");

      // Test that module.pmod functions are accessible
      array(string) funcs = ({"is_type_keyword", "is_identifier", "find_next_token",
                              "find_matching_brace", "try_parse_declaration"});
      foreach (funcs, string func_name) {
        if (!functionp(mod[func_name])) {
          werror("FAIL: %s not found in module\n", func_name); exit(1);
        }
      }
      werror("OK: module.pmod functions accessible\n");
    '

    Create summary at .planning/phases/05-pike-reorganization/05-03-SUMMARY.md
  </action>
  <verify>Summary file exists and verification commands pass</verify>
  <done>Module loads correctly, summary created</done>
</task>

</tasks>

<verification>
## Module Loading Tests

```bash
pike -e '
  master()->add_module_path("pike-scripts");
  mixed mod = master()->resolv("LSP.Analysis");
  if (!mod || !programp(mod->Diagnostics)) { exit(1); }
  werror("PASS: Analysis module loaded\n");
'
```

## File Structure Verification

- [ ] pike-scripts/LSP.pmod/Analysis.pmod/ exists
- [ ] pike-scripts/LSP.pmod/Analysis.pmod/module.pmod exists (200+ lines)
- [ ] pike-scripts/LSP.pmod/Analysis.pmod/Diagnostics.pike exists (500+ lines)
- [ ] Original Analysis.pike still exists (not deleted yet)
</verification>

<success_criteria>
1. Analysis.pmod directory exists with module.pmod and Diagnostics.pike
2. module.pmod contains 15+ helper functions and STATE_* constants
3. Diagnostics class has create(object ctx) constructor
4. handle_analyze_uninitialized uses catch with graceful degradation
5. master()->resolv("LSP.Analysis.Diagnostics") returns the class
</success_criteria>

<output>
After completion, create `.planning/phases/05-pike-reorganization/05-03-SUMMARY.md`
</output>
