---
phase: 05-pike-reorganization
plan: 05
type: execute
wave: 3
depends_on: ["05-02", "05-04"]
files_modified:
  - pike-scripts/LSP.pmod/Intelligence.pike
  - pike-scripts/LSP.pmod/Analysis.pike
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Old Intelligence.pike and Analysis.pike are replaced with delegating stubs"
    - "Delegating classes forward to new .pmod classes"
    - "Backward compatibility maintained (existing code still works)"
    - "Intelligence.pike reduced from 1660 to ~100 lines"
    - "Analysis.pike reduced from 1191 to ~80 lines"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Intelligence.pike"
      provides: "Delegating Intelligence class that forwards to specialized handlers"
      min_lines: 80
    - path: "pike-scripts/LSP.pmod/Analysis.pike"
      provides: "Delegating Analysis class that forwards to specialized handlers"
      min_lines: 60
  key_links:
    - from: "pike-scripts/LSP.pmod/Intelligence.pike"
      to: "pike-scripts/LSP.pmod/Intelligence.pmod/*"
      via: "master()->resolv() to load specialized classes"
      pattern: "master\(\)->resolv\(\"LSP\.Intelligence\.Introspection\"\)"
    - from: "pike-scripts/LSP.pmod/Analysis.pike"
      to: "pike-scripts/LSP.pmod/Analysis.pmod/*"
      via: "master()->resolv() to load specialized classes"
      pattern: "master\(\)->resolv\(\"LSP\.Analysis\.Diagnostics\"\)"
---

<objective>
Replace original Intelligence.pike and Analysis.pike with backward-compatible delegating stubs.

Purpose: Complete the Pike reorganization by replacing the large single-file classes with compact delegating classes that forward to the new modular structure, maintaining backward compatibility for existing code.
Output: Original single-file classes replaced with delegating stubs (~100 lines vs 1660 for Intelligence, ~80 lines vs 1191 for Analysis)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Phase context
@.planning/phases/05-pike-reorganization/05-CONTEXT.md
@.planning/phases/05-pike-reorganization/05-RESEARCH.md
@.planning/phases/05-pike-reorganization/05-02-SUMMARY.md
@.planning/phases/05-pike-reorganization/05-04-SUMMARY.md

# Files to modify
@pike-scripts/LSP.pmod/Intelligence.pike
@pike-scripts/LSP.pmod/Analysis.pike
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backward-compatible Intelligence.pike delegating class</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
    Replace the original Intelligence.pike (1,660 lines) with a compact delegating class.

    Key decision from RESEARCH.md Q1: Keep a delegating Intelligence class for backward compatibility.
    This allows analyzer.pike to continue using the existing pattern without changes.

    New Intelligence.pike structure:
    ```pike
    //! Intelligence.pike - Backward-compatible delegating class
    //!
    //! This class delegates to the new modular structure in Intelligence.pmod/
    //!
    //! After v2 reorganization:
    //! - Introspection.pike: Symbol extraction
    //! - Resolution.pike: Module resolution, stdlib introspection
    //! - TypeAnalysis.pike: Inheritance, AutoDoc parsing

    //! Import the modular classes
    // Note: When master()->resolv("LSP.Intelligence") is called,
    // Pike finds Intelligence.pmod/ directory first
    // This file provides the backward-compatible Intelligence class

    constant Cache = LSP.Cache;

    //! State tracking for stdlib resolution (circular dependency guard)
    private mapping(string:int) resolving_modules = ([]);
    private mapping(string:int) circular_refs = ([]);

    //! Bootstrap modules that can't be resolved during introspection
    constant BOOTSTRAP_MODULES = (<
        "Stdio", "String", "Array", "Mapping"
    >);

    //! Intelligence class - Delegates to specialized classes
    class Intelligence {
        private object introspection_handler;
        private object resolution_handler;
        private object type_analysis_handler;

        void create() {
            // Create instances of the specialized classes
            mixed introspection_class = master()->resolv("LSP.Intelligence.Introspection");
            mixed resolution_class = master()->resolv("LSP.Intelligence.Resolution");
            mixed type_analysis_class = master()->resolv("LSP.Intelligence.TypeAnalysis");

            if (introspection_class && programp(introspection_class)) {
                introspection_handler = introspection_class(0);
            }
            if (resolution_class && programp(resolution_class)) {
                resolution_handler = resolution_class(0);
            }
            if (type_analysis_class && programp(type_analysis_class)) {
                type_analysis_handler = type_analysis_class(0);
            }
        }

        //! Delegate introspect to Introspection class
        mapping handle_introspect(mapping params) {
            if (introspection_handler) {
                return introspection_handler->handle_introspect(params);
            }
            return LSP.module.LSPError(-32000, "Introspection handler not available")->to_response();
        }

        //! Delegate resolve to Resolution class
        mapping handle_resolve(mapping params) {
            if (resolution_handler) {
                return resolution_handler->handle_resolve(params);
            }
            return LSP.module.LSPError(-32000, "Resolution handler not available")->to_response();
        }

        //! Delegate resolve_stdlib to Resolution class
        mapping handle_resolve_stdlib(mapping params) {
            if (resolution_handler) {
                return resolution_handler->handle_resolve_stdlib(params);
            }
            return LSP.module.LSPError(-32000, "Resolution handler not available")->to_response();
        }

        //! Delegate get_inherited to TypeAnalysis class
        mapping handle_get_inherited(mapping params) {
            if (type_analysis_handler) {
                return type_analysis_handler->handle_get_inherited(params);
            }
            return LSP.module.LSPError(-32000, "TypeAnalysis handler not available")->to_response();
        }
    }
    ```

    Important notes:
    1. When master()->resolv("LSP.Intelligence") is called, Pike finds Intelligence.pmod/ directory
    2. This file is resolved because it's inside the .pmod directory
    3. The Intelligence class provides backward compatibility
    4. Each handler delegates to the appropriate specialized class
    5. Error handling uses LSP.module.LSPError pattern (consistent with Phase 01)
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Intelligence"); if (m && m->Intelligence && programp(m->Intelligence)) { werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>Intelligence.pike replaced with delegating class (~100 lines)</done>
</task>

<task type="auto">
  <name>Task 2: Create backward-compatible Analysis.pike delegating class</name>
  <files>pike-scripts/LSP.pmod/Analysis.pike</files>
  <action>
    Replace the original Analysis.pike (1,191 lines) with a compact delegating class.

    New Analysis.pike structure:
    ```pike
    //! Analysis.pike - Backward-compatible delegating class
    //!
    //! This class delegates to the new modular structure in Analysis.pmod/
    //!
    //! After v2 reorganization:
    //! - Diagnostics.pike: Uninitialized variable analysis
    //! - Completions.pike: Completion context analysis
    //! - Variables.pike: Find occurrences

    //! Analysis class - Delegates to specialized classes
    class Analysis {
        private object diagnostics_handler;
        private object completions_handler;
        private object variables_handler;

        void create() {
            // Create instances of the specialized classes
            mixed diagnostics_class = master()->resolv("LSP.Analysis.Diagnostics");
            mixed completions_class = master()->resolv("LSP.Analysis.Completions");
            mixed variables_class = master()->resolv("LSP.Analysis.Variables");

            if (diagnostics_class && programp(diagnostics_class)) {
                diagnostics_handler = diagnostics_class(0);
            }
            if (completions_class && programp(completions_class)) {
                completions_handler = completions_class(0);
            }
            if (variables_class && programp(variables_class)) {
                variables_handler = variables_class(0);
            }
        }

        //! Delegate analyze_uninitialized to Diagnostics class
        mapping handle_analyze_uninitialized(mapping params) {
            if (diagnostics_handler) {
                return diagnostics_handler->handle_analyze_uninitialized(params);
            }
            return (["result": (["diagnostics": ({}))]);
        }

        //! Delegate get_completion_context to Completions class
        mapping handle_get_completion_context(mapping params) {
            if (completions_handler) {
                return completions_handler->handle_get_completion_context(params);
            }
            return (["result": (["context": "none", "objectName": "", "prefix": "", "operator": ""])]);
        }

        //! Delegate find_occurrences to Variables class
        mapping handle_find_occurrences(mapping params) {
            if (variables_handler) {
                return variables_handler->handle_find_occurrences(params);
            }
            return LSP.module.LSPError(-32000, "Variables handler not available")->to_response();
        }
    }
    ```

    Note: This is smaller than Intelligence.pike because Analysis has only 3 handlers vs 4
    Error handling uses LSP.module.LSPError pattern for find_occurrences, graceful degradation for others
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Analysis"); if (m && m->Analysis && programp(m->Analysis)) { werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>Analysis.pike replaced with delegating class (~80 lines)</done>
</task>

<task type="auto">
  <name>Task 3: Verify analyzer.pike Context works with new structure</name>
  <files></files>
  <action>
    Verify that analyzer.pike can still instantiate Intelligence and Analysis classes
    using the existing pattern.

    Read analyzer.pike to confirm the Context creation pattern:
    grep -A 10 "IntelligenceClass\|AnalysisClass" pike-scripts/analyzer.pike

    The existing pattern should be:
    - Program IntelligenceClass = master()->resolv("LSP.Intelligence")->Intelligence;
    - Program AnalysisClass = master()->resolv("LSP.Analysis")->Analysis;

    Test that instantiation works:
    pike -e '
      master()->add_module_path("pike-scripts");

      // Test Intelligence
      mixed intel_mod = master()->resolv("LSP.Intelligence");
      if (!intel_mod) { werror("FAIL: LSP.Intelligence not resolved\n"); exit(1); }
      werror("OK: LSP.Intelligence resolved\n");

      mixed intel_cls = intel_mod->Intelligence;
      if (!programp(intel_cls)) { werror("FAIL: Intelligence class not found\n"); exit(1); }
      werror("OK: Intelligence class found\n");

      object intel = intel_cls();
      werror("OK: Intelligence instantiated\n");

      // Test Analysis
      mixed analysis_mod = master()->resolv("LSP.Analysis");
      if (!analysis_mod) { werror("FAIL: LSP.Analysis not resolved\n"); exit(1); }
      werror("OK: LSP.Analysis resolved\n");

      mixed analysis_cls = analysis_mod->Analysis;
      if (!programp(analysis_cls)) { werror("FAIL: Analysis class not found\n"); exit(1); }
      werror("OK: Analysis class found\n");

      object analysis = analysis_cls();
      werror("OK: Analysis instantiated\n");

      werror("PASS: All handlers accessible\n");
    '

    If verification passes, no changes to analyzer.pike are needed.

    Create summary at .planning/phases/05-pike-reorganization/05-05-SUMMARY.md
  </action>
  <verify>analyzer.pike can instantiate Intelligence and Analysis classes</verify>
  <done>analyzer.pike Context works with new structure (no changes needed)</done>
</task>

</tasks>

<verification>
## Delegating Class Tests

```bash
pike -e '
  master()->add_module_path("pike-scripts");

  // Test Intelligence delegation
  mixed intel = master()->resolv("LSP.Intelligence")->Intelligence();
  if (!intel) { werror("FAIL: Intelligence instantiation\n"); exit(1); }
  werror("OK: Intelligence delegates\n");

  // Test Analysis delegation
  mixed analysis = master()->resolv("LSP.Analysis")->Analysis();
  if (!analysis) { werror("FAIL: Analysis instantiation\n"); exit(1); }
  werror("OK: Analysis delegates\n");

  werror("PASS: Delegating classes work\n");
'
```

## Line Count Verification

- [ ] pike-scripts/LSP.pmod/Intelligence.pike: ~100 lines (down from 1660)
- [ ] pike-scripts/LSP.pmod/Analysis.pike: ~80 lines (down from 1191)
</verification>

<success_criteria>
1. Intelligence.pike: 1660 -> ~100 lines (94% reduction)
2. Analysis.pike: 1191 -> ~80 lines (93% reduction)
3. LSP.Intelligence.Intelligence class loads and instantiates
4. LSP.Analysis.Analysis class loads and instantiates
5. analyzer.pike can use existing pattern (no changes needed)
6. All handlers forward correctly to specialized classes
</success_criteria>

<output>
After completion, create `.planning/phases/05-pike-reorganization/05-05-SUMMARY.md`
</output>
