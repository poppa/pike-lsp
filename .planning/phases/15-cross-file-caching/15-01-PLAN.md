---
phase: 15-cross-file-caching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/pike-lsp-server/benchmarks/fixtures/cross-file/main.pike
  - packages/pike-lsp-server/benchmarks/fixtures/cross-file/lib/utils.pike
  - packages/pike-lsp-server/benchmarks/runner.ts
  - pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
  - pike-scripts/analyzer.pike
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Compiling main.pike (which inherits lib/utils.pike) results in both files being cached"
    - "Recompiling main.pike with same version reuses lib/utils.pike from cache"
    - "Invalidating lib/utils.pike also invalidates main.pike (transitive invalidation)"
    - "DependencyTrackingCompiler.extract_dependencies() correctly identifies inherit statements"
  artifacts:
    - path: "packages/pike-lsp-server/benchmarks/fixtures/cross-file/main.pike"
      provides: "Test fixture with inherit relationship"
      contains: "inherit.*lib/utils.pike"
    - path: "packages/pike-lsp-server/benchmarks/fixtures/cross-file/lib/utils.pike"
      provides: "Dependency file to be inherited"
    - path: "packages/pike-lsp-server/benchmarks/runner.ts"
      provides: "Cross-file cache verification benchmarks"
      contains: "Cross-File Cache"
    - path: "pike-scripts/analyzer.pike"
      provides: "invalidate_cache RPC handler for testing"
      exports: ["invalidate_cache"]
  key_links:
    - from: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      to: "LSP.CompilationCache.DependencyTrackingCompiler"
      via: "compile_with_tracking() instead of compile_string()"
      pattern: "DependencyTrackingCompiler.*compile_with_tracking"
    - from: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      to: "CompilationResult.dependencies"
      via: "Passing extracted dependencies array to ResultClass constructor"
      pattern: "extract_dependencies.*ResultClass"
---

<objective>
Verify that Phase 13's compilation cache correctly handles cross-file scenarios (inherit/import) and fix any gaps found during verification.

Purpose: Phase 13 built dependency tracking infrastructure (DependencyTrackingCompiler, bidirectional graph, transitive invalidation), but line 756 of Analysis.pmod/module.pmod stores results with empty dependencies. This phase verifies whether this breaks cross-file caching and fixes it if needed.

Output: Working cross-file caching with dependency tracking, or documented gap if fix exceeds 2-hour timebox.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-cross-file-caching/15-CONTEXT.md
@.planning/phases/15-cross-file-caching/15-RESEARCH.md
@.planning/phases/13-pike-side-compilation-caching/13-03-SUMMARY.md
@pike-scripts/LSP.pmod/CompilationCache.pmod
@packages/pike-lsp-server/benchmarks/runner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cross-file test fixtures</name>
  <files>packages/pike-lsp-server/benchmarks/fixtures/cross-file/main.pike</files>
  <files>packages/pike-lsp-server/benchmarks/fixtures/cross-file/lib/utils.pike</files>
  <action>
    Create test fixtures for cross-file caching verification:

    1. Create directory: packages/pike-lsp-server/benchmarks/fixtures/cross-file/lib/

    2. Create lib/utils.pike:
    ```pike
    //! Utility base class for cross-file caching tests
    class Utils {
        string get_greeting() {
            return "Hello from utils";
        }

        int add(int a, int b) {
            return a + b;
        }
    }
    ```

    3. Create main.pike:
    ```pike
    //! Main class that inherits from utils - for dependency tracking tests
    inherit "lib/utils.pike";

    class Main {
        void run() {
            object utils = Utils();
            string greeting = utils->get_greeting();
        }
    }
    ```

    Use inherit (not #include) to test real dependency tracking.
  </action>
  <verify>
    ls -la packages/pike-lsp-server/benchmarks/fixtures/cross-file/lib/
    cat packages/pike-lsp-server/benchmarks/fixtures/cross-file/main.pike
    cat packages/pike-lsp-server/benchmarks/fixtures/cross-file/lib/utils.pike
  </verify>
  <done>
    Both fixture files exist, main.pike has inherit "lib/utils.pike"
  </done>
</task>

<task type="auto">
  <name>Task 2: Add invalidate_cache RPC handler</name>
  <files>pike-scripts/analyzer.pike</files>
  <action>
    Add invalidate_cache RPC handler to enable deterministic testing of cache invalidation.

    In pike-scripts/analyzer.pike, find the HANDLERS mapping (around line 100-150) and add:

    ```pike
    "invalidate_cache": lambda(mapping params, object ctx) {
        mixed CacheClass = master()->resolv("LSP.CompilationCache");
        if (CacheClass && programp(CacheClass)) {
            string path = params->path || "";
            int transitive = params->transitive || 0;

            // Resolve path relative to project root if not absolute
            if (sizeof(path) > 0 && path[0] != '/') {
                path = combine_path(getcwd(), path);
            }

            if (transitive) {
                CacheClass->invalidate(path, 1);  // Transitive invalidation
            } else {
                CacheClass->invalidate(path, 0);  // Direct invalidation
            }

            return (["result": (["status": "invalidated", "path": path])]);
        }
        return (["error": (["code": -32601, "message": "Cache not available"])]);
    },
    ```

    This handler is needed for testing: allows benchmarks to invalidate specific cache entries to verify transitive invalidation behavior.
  </action>
  <verify>
    grep -n "invalidate_cache" pike-scripts/analyzer.pike
    pike -e 'compile_file("pike-scripts/analyzer.pike");'
  </verify>
  <done>
    invalidate_cache handler exists in HANDLERS mapping, Pike script compiles
  </done>
</task>

<task type="auto">
  <name>Task 3: Add cross-file verification benchmarks</name>
  <files>packages/pike-lsp-server/benchmarks/runner.ts</files>
  <action>
    Add "Cross-File Cache Verification" benchmark group after the existing "Compilation Cache" group (after line 185).

    Import fixtures:
    ```typescript
    const mainCode = fs.readFileSync(
      path.join(__dirname, 'fixtures/cross-file/main.pike'),
      'utf8'
    );
    const utilsCode = fs.readFileSync(
      path.join(__dirname, 'fixtures/cross-file/lib/utils.pike'),
      'utf8'
    );
    ```

    Add benchmark group:
    ```typescript
    // PERF-15-01: Cross-file cache verification
    group('Cross-File Cache Verification', async () => {
      // First compile utils.pike directly
      await bridge.analyze(utilsCode, ['introspect'], 'lib/utils.pike', 1);

      // Benchmark: Compile main.pike (should inherit utils.pike from cache)
      bench('Cross-file: compile main with inherited utils', async () => {
        const response = await bridge.analyze(mainCode, ['introspect'], 'main.pike', 1);
        return response;
      });

      // Benchmark: Verify cache hit on recompile
      bench('Cross-file: recompile main (cache hit)', async () => {
        const response = await bridge.analyze(mainCode, ['introspect'], 'main.pike', 1);
        return response;
      });
    });
    ```

    Then after the run() call (before the final stats output), add verification logging:
    ```typescript
    // PERF-15-01: Cross-file cache verification output
    if (!process.env.MITATA_JSON) {
      console.log('\n=== Cross-File Cache Verification ===');
      try {
        const cacheStats = await (bridge as any).sendRequest('get_cache_stats', {});
        console.log(`Files in cache: ${cacheStats.size || 0}`);

        // Get dependency graph info (if available via future RPC)
        console.log('Verification: Check if both main.pike and lib/utils.pike are cached');
      } catch (e) {
        console.log('Cache stats not available:', e);
      }
    }
    ```
  </action>
  <verify>
    grep -n "Cross-File Cache" packages/pike-lsp-server/benchmarks/runner.ts
  </verify>
  <done>
    Cross-File Cache Verification group exists in runner.ts
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Test fixtures, invalidate_cache handler, and cross-file benchmarks</what-built>
  <how-to-verify>
    1. Run benchmarks to see current behavior:
       cd packages/pike-lsp-server && pnpm benchmark

    2. Check output for "Cross-File Cache Verification" section
    3. Note cache size - should be at least 2 files if cross-file caching works

    Expected CURRENT behavior (before fix):
    - Files in cache: 1 (only main.pike, utils.pike not cached separately)
    - Dependencies array is empty (gap from line 756)

    Expected DESIRED behavior (after fix):
    - Files in cache: 2 (both main.pike and lib/utils.pike)
    - Dependencies array contains lib/utils.pike path

    If verification shows the gap (empty deps), continue to Task 4 to fix.
    If verification passes (deps populated), skip to Task 5.
  </how-to-verify>
  <resume-signal>Type "continue" if gap confirmed, or "skip" if dependencies are already tracked</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Wire DependencyTrackingCompiler into compilation flow</name>
  <files>pike-scripts/LSP.pmod/Analysis.pmod/module.pmod</files>
  <action>
    Fix the gap: connect DependencyTrackingCompiler to capture dependencies during compilation.

    In pike-scripts/LSP.pmod/Analysis.pmod/module.pmod, find the compilation block (around line 736-760):

    1. Replace compile_string() with DependencyTrackingCompiler.compile_with_tracking():
       - Change: `compiled_prog = compile_string(code, filename);`
       - To: Use DependencyTrackingCompiler class

    2. Capture extracted dependencies:
       - After compilation, call compiler->get_dependencies()
       - Pass dependencies to ResultClass constructor

    Implementation:
    ```pike
    // Cache miss - compile with dependency tracking
    if (!compiled_prog) {
        object compile_timer2 = System.Timer();

        // Use DependencyTrackingCompiler to capture dependencies
        mixed CompilerClass = master()->resolv("LSP.CompilationCache.DependencyTrackingCompiler");
        mixed compile_err;

        if (CompilerClass && programp(CompilerClass)) {
            // Use dependency tracking compiler
            object compiler = CompilerClass();
            compile_err = catch {
                compiled_prog = compiler->compile_with_tracking(code, filename);
            };

            if (!compile_err && compiled_prog && cache && cache_key) {
                // Get captured dependencies and store in cache
                array(string) deps = compiler->get_dependencies();
                mixed ResultClass = master()->resolv("LSP.CompilationCache.CompilationResult");
                if (ResultClass && programp(ResultClass)) {
                    object result = ResultClass(compiled_prog, ({}), deps);
                    cache->put(filename, cache_key, result);
                }
            }
        } else {
            // Fallback to plain compilation if DependencyTrackingCompiler unavailable
            compile_err = catch {
                compiled_prog = compile_string(code, filename);
            };
        }

        compilation_ms = compile_timer2->peek() * 1000.0;

        if (compile_err || !compiled_prog) {
            failures->introspect = ([
                "message": describe_error(compile_err || "Compilation failed"),
                "kind": "CompilationError"
            ]);
        }
    }
    ```

    Key changes:
    1. Instantiate DependencyTrackingCompiler before compilation
    2. Call compile_with_tracking() instead of compile_string()
    3. Extract dependencies via compiler->get_dependencies()
    4. Pass deps array to ResultClass constructor (was ({}), now deps)
    5. Move cache->put inside the DependencyTrackingCompiler branch

    IMPORTANT: Remove the old cache->put block at lines 750-758 (the "Create CompilationResult with empty dependencies" section).
  </action>
  <verify>
    grep -n "DependencyTrackingCompiler\|compile_with_tracking\|get_dependencies" pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
    pike -e 'compile_file("pike-scripts/LSP.pmod/Analysis.pmod/module.pmod");'
    pike -e 'compile_file("pike-scripts/analyzer.pike");'
  </verify>
  <done>
    DependencyTrackingCompiler wired into handle_analyze compilation path, Pike compiles
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Fixed dependency tracking in compilation flow (or confirmed existing behavior is correct)</what-built>
  <how-to-verify>
    1. Run benchmarks again:
       cd packages/pike-lsp-server && pnpm benchmark

    2. Check "Cross-File Cache Verification" section output

    3. Verify cache behavior:
       - Files in cache: 2+ (main.pike + lib/utils.pike)
       - Cache hit rate improves on second run

    4. Test transitive invalidation manually (in node REPL):
       ```javascript
       import { PikeBridge } from '@pike-lsp/pike-bridge';
       const bridge = new PikeBridge();
       await bridge.start();
       await bridge.analyze(mainCode, ['introspect'], 'main.pike', 1);
       await bridge.sendRequest('invalidate_cache', { path: 'lib/utils.pike', transitive: true });
       const stats = await bridge.sendRequest('get_cache_stats', {});
       console.log('Cache size after transitive invalidation:', stats.size);
       // Should be 0 (both files removed)
       await bridge.stop();
       ```

    If all checks pass: Type "approved"
    If issues found: Describe the problem
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
Overall phase verification:

1. Pike compiles without errors:
   pike -e 'compile_file("pike-scripts/analyzer.pike");'

2. Benchmarks run successfully:
   cd packages/pike-lsp-server && pnpm benchmark

3. Cross-file verification shows:
   - Both main.pike and lib/utils.pike are cached after compilation
   - Recompiling main.pike hits cache (lib/utils.pike reused)
   - Invalidating lib/utils.pike also removes main.pike (transitive invalidation)

4. Timebox check: If fix took > 2 hours, document gap in SUMMARY and defer to Phase 15.1
</verification>

<success_criteria>
Cross-file caching works end-to-end:
- Compiling a file that inherits another caches both files
- Dependency graph tracks the inherit relationship
- Invalidating dependency invalidates dependents
- OR: Gap documented with timebox rationale if fix exceeded 2 hours
</success_criteria>

<output>
After completion, create `.planning/phases/15-cross-file-caching/15-01-SUMMARY.md`

Include:
- Whether dependencies were being tracked (verification result)
- Whether fix was needed and applied
- Time spent on fix (for timebox evaluation)
- Cache size and hit rate measurements
- Transitive invalidation test results
- Any gaps deferred to future phases
</output>
