---
phase: 16-stdlib-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike
  - pike-scripts/LSP.pmod/Intelligence.pmod/Introspection.pike
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Stdlib modules load without 'Parent lost' crashes"
    - "Direct object introspection returns symbols for all stdlib modules"
    - "Bootstrap modules (Stdio, String, Array, Mapping) return data"
    - "No circular dependency or timeout errors during introspection"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike"
      provides: "handle_resolve_stdlib with direct object introspection"
      contains: "indices(resolved)"
    - path: "pike-scripts/LSP.pmod/Intelligence.pmod/Introspection.pike"
      provides: "introspect_object() method for direct object introspection"
      exports: ["introspect_object"]
  key_links:
    - from: "Resolution.pike"
      to: "resolved object"
      via: "indices() and values() calls"
      pattern: "indices\\(resolved\\)|values\\(resolved\\)"
    - from: "handle_resolve_stdlib"
      to: "bootstrap modules"
      via: "direct introspection without program instantiation"
      pattern: "!programp\\(resolved\\)"
---

<objective>
Fix stdlib introspection to work without "Parent lost" crashes by using direct object introspection instead of program instantiation.

Purpose: Current stdlib introspection fails for bootstrap modules (Stdio, String, Array, Mapping) because it tries to instantiate programs via prog(), which triggers "Parent lost, cannot clone program" errors. These modules are already loaded as singleton objects by Pike and can be introspected directly.

Output: Working stdlib introspection that returns symbols for all stdlib modules including bootstrap modules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/16-stdlib-performance/16-RESEARCH.md
@.planning/ROADMAP.md
@.planning/STATE.md

@pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike
@pike-scripts/LSP.pmod/Intelligence.pmod/Introspection.pike
</context>

<tasks>

<task type="auto">
  <name>Add introspect_object() method to Introspection.pike</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pmod/Introspection.pike</files>
  <action>
    Add a new method introspect_object() that introspects a singleton object directly without instantiation.

    The method should:
    1. Accept an object (not a program) as parameter
    2. Call indices() and values() directly on the object (no prog() call)
    3. Return the same mapping format as introspect_program() (symbols, functions, variables, classes, inherits)

    Pattern to follow:
    ```pike
    mapping introspect_object(object obj) {
        // Similar to introspect_program but skip instantiation
        // Get symbols directly via indices/values on the object
        array symbol_names = indices(obj);
        array symbol_values = values(obj);
        // ... extract symbols same way as introspect_program
    }
    ```

    Place this method after introspect_program() and before the end of the file.
  </action>
  <verify>grep -q "introspect_object" pike-scripts/LSP.pmod/Intelligence.pmod/Introspection.pike</verify>
  <done>introspect_object() method exists and accepts object parameter</done>
</task>

<task type="auto">
  <name>Modify handle_resolve_stdlib to use direct object introspection</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike</files>
  <action>
    Update handle_resolve_stdlib() to introspect the resolved object directly instead of trying to get the program and instantiate it.

    Changes:
    1. After master()->resolv() succeeds, check if resolved is already an object (objectp(resolved))
    2. If it's an object, introspect it directly using indices()/values() OR call new introspect_object()
    3. Only fall back to object_program(resolved) + introspect_program() for non-object cases

    Key change in the "Get program for introspection" section (lines 206-214):
    - Current: Always tries to get program via object_program() or programp()
    - New: If objectp(resolved), introspect directly. Only get program if not already an object.

    Important: Remove or modify the bootstrap module guard (lines 157-166). Instead of returning "bootstrap: 1", allow these modules through but use direct introspection for them.

    For non-objects (programs), keep the existing introspect_program() flow.
  </action>
  <verify>grep -n "indices(resolved)" pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike</verify>
  <done>handle_resolve_stdlib() uses direct introspection for objects, no bootstrap guard blocking Stdio/String/Array/Mapping</done>
</task>

<task type="auto">
  <name>Test stdlib introspection returns symbols for bootstrap modules</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike</files>
  <action>
    Create a quick manual test to verify the fix works. Use the existing Pike bridge to test:

    Test command:
    ```bash
    cd packages/pike-lsp-server && cat > /tmp/test-stdlib.mjs << 'EOF'
    import { PikeBridge } from '@pike-lsp/pike-bridge';

    const bridge = new PikeBridge();
    await bridge.start();

    const testModules = ['Stdio', 'String', 'Array', 'Mapping'];
    for (const mod of testModules) {
      const result = await bridge.resolveStdlib(mod);
      console.log(`${mod}: found=${result.found}, bootstrap=${result.bootstrap}, symbols=${result.symbols?.length || 0}`);
    }

    await bridge.stop();
    EOF
    node /tmp/test-stdlib.mjs
    ```

    Expected result: All modules should show found=true, symbols > 0, and NO bootstrap=1 flag.

    If any module fails with "Parent lost" or returns bootstrap=1, the fix is incomplete.
  </action>
  <verify>Test command shows found=true and symbols > 0 for Stdio, String, Array, Mapping</verify>
  <done>All bootstrap modules return symbols without "Parent lost" errors</done>
</task>

</tasks>

<verification>
Run the test command from Task 3. Verify:
- [ ] Stdio returns found=true with symbols
- [ ] String returns found=true with symbols
- [ ] Array returns found=true with symbols
- [ ] Mapping returns found=true with symbols
- [ ] No "Parent lost" errors in stderr
- [ ] response does NOT contain bootstrap:1 flag
</verification>

<success_criteria>
1. Stdlib modules (including bootstrap) load without "Parent lost" crashes
2. Direct object introspection returns symbols for all tested modules
3. handle_resolve_stdlib() no longer blocks bootstrap modules
</success_criteria>

<output>
After completion, create `.planning/phases/16-stdlib-performance/16-01-SUMMARY.md`
</output>
